# Авторизация и токены в проекте автооткликов
**Назначение:** сводка по использованию авторизации, получению и сохранению токенов в черновике проекта автооткликов (Rezume / hh-applicant-tool).

---

## Краткий вывод

- **Где авторизация:** в подпроекте `hh-applicant-tool` через OAuth 2.0 hh.ru и браузер (Playwright).
- **Как получают токен:** перехват redirect `hhandroid://oauth?code=...` → обмен `code` на `access_token` и `refresh_token` через API hh.ru.
- **Где хранятся токены:** в файле `config.json` (путь зависит от ОС), через класс `Config` и метод `save(token=...)`.
- **Как используют:** все скрипты читают токен из `config.json`, подставляют в заголовок `Authorization: Bearer <access_token>`; при истечении — обновляют через `refresh_token` и снова сохраняют в конфиг.

---

## 1. Где происходит авторизация

| Что | Где |
|-----|-----|
| **Основная точка входа** | `hh-applicant-tool` (CLI и операции) |
| **Код авторизации (OAuth в браузере)** | `hh-applicant-tool/hh_applicant_tool/operations/authorize.py` |
| **Альтернативный скрипт с паролем** | `hh-applicant-tool/authorize_with_password.py` |
| **Проверка авторизации** | `hh-applicant-tool/check_auth.py` |
| **Документация по интеграции** | `README_AI_BROWSER_INTEGRATION.md`, `INTEGRATION_AI_BROWSER_SUMMARY.md` |
| **Упоминания в других частях проекта** | `job-automation-resources/CODE_MAP.md`, `job-automation-resources/ДАННЫЕ_СБОРА_АНАЛИЗ.md`, `BPMN/vacancy_application_process_with_api.md` |

---

## 2. Как получают токен авторизации

### 2.1 OAuth-поток (authorize.py)

1. Запускается **Playwright** (Chromium), контекст устройства — **Galaxy A55** (имитация Android).
2. Переход на `api_client.oauth_client.authorize_url` (страница OAuth hh.ru).
3. Пользователь вводит логин (email/телефон) и либо пароль, либо одноразовый код.
4. После входа hh.ru перенаправляет на схему **`hhandroid://oauth?code=...`**.
5. Обработчик `page.on("request", handle_request)` **перехватывает** этот redirect и извлекает `code` из URL.
6. Код обменивается на токены через **OAuthClient**:
   - `api_client.oauth_client.authenticate(auth_code)` → запрос к `https://hh.ru/oauth/token` с `grant_type=authorization_code` и `code=...`.
7. Ответ содержит `access_token`, `refresh_token`, `expires_in`. В коде добавляется `access_expires_at = time.time() + expires_in`.
8. Токен передаётся в **ApiClient**: `api_client.handle_access_token(token)`.

**Ключевые места в коде:**

- Перехват кода: `hh_applicant_tool/operations/authorize.py` (строки ~131–139, 164–176).
- Обмен кода на токен: `hh_applicant_tool/api/client.py` — `OAuthClient.authenticate(code)` и `request_access_token("/token", params)`.
- Имитация Android: используются константы `ANDROID_CLIENT_ID` и `ANDROID_CLIENT_SECRET` из `hh_applicant_tool/constants.py`.

### 2.2 Обновление токена (refresh)

- При истечении `access_token` (проверка `api_client.is_access_expired`) вызывается `api_client.refresh_access_token()`.
- Запрос к `https://hh.ru/oauth/token` с `grant_type=refresh_token` и `refresh_token=...`.
- Новый `access_token` и при необходимости новый `refresh_token` записываются в ApiClient через `handle_access_token(token)`.
- Обновлённый токен сохраняется в конфиг (см. ниже).

**Код:** `hh_applicant_tool/api/client.py` — метод `refresh_access_token()` у `OAuthClient` и у `ApiClient`; автоматический refresh при 403 в `ApiClient.request()`.

---

## 3. Сохранение токена

### 3.1 Куда сохраняется

- **Файл:** `config.json`.
- **Путь к файлу** (функция `get_config_path()` в `hh_applicant_tool/utils.py`):
  - **Windows:** `%APPDATA%\hh-applicant-tool\config.json` (например, `C:\Users\<user>\AppData\Roaming\hh-applicant-tool\config.json`).
  - **macOS:** `~/Library/Application Support/hh-applicant-tool/config.json`.
  - **Linux/прочее:** `$XDG_CONFIG_HOME/hh-applicant-tool/config.json` или `~/.config/hh-applicant-tool/config.json`.

Полный путь в коде часто собирается как:  
`get_config_path() / "hh-applicant-tool" / "config.json"`.

### 3.2 Как сохраняется

- Класс **Config** (`hh_applicant_tool/utils.py`): наследует `dict`, метод `save(*args, **kwargs)` делает `self.update(*args, **kwargs)` и записывает JSON в `_config_path`.
- Сохранение токена: `config.save(token=token)`, где `token` — словарь вида:
  - `access_token`: строка
  - `refresh_token`: строка
  - `access_expires_at`: int (Unix timestamp)

В конфиге токен лежит под ключом **`token`** (т.е. в `config["token"]`).

### 3.3 Где вызывается сохранение

| Место | Действие |
|-------|----------|
| `hh_applicant_tool/main.py` | После любой операции (`args.run`): если `api_client.get_access_token()` отличается от `args.config["token"]`, вызывается `args.config.save(token=token)`. Таким образом, после авторизации или refresh токен автоматически попадает в конфиг. |
| `hh_applicant_tool/operations/authorize.py` | Сама операция только вызывает `api_client.handle_access_token(token)`; запись в конфиг выполняет общий код в `main.py` после `args.run`. |
| `authorize_with_password.py` | После успешной авторизации: `config.save(token=api_client.get_access_token())`. |
| `check_auth.py` | После успешного обновления токена по refresh: `config.save(token=api_client.get_access_token())`. |

---

## 4. Использование токена в запросах

- **ApiClient** при наличии `access_token` добавляет в заголовки:  
  `authorization: Bearer <access_token>`  
  (в коде: `headers | {"authorization": f"Bearer {self.access_token}"}`).
- Токены загружаются из конфига при создании ApiClient в `main.py`:  
  `config.get("token", {})` → `access_token`, `refresh_token`, `access_expires_at` передаются в конструктор ApiClient.
- Отдельные скрипты (например, `check_negotiations_structure.py`, `analyze_negotiations_list.py`, `test_vacancy_from_negotiation_click.py`, `create_mobile_client.py` и др.) сами читают `config.json`, достают `config.get("token", {}).get("access_token")` и либо создают ApiClient с этими полями, либо подставляют заголовок `Authorization: Bearer {access_token}` в свои запросы.

---

## 5. Тип токена (структура)

В `hh_applicant_tool/types.py` описан **AccessToken** (TypedDict):

- `access_token`: str  
- `refresh_token`: str  
- `expires_in`: int  
- `token_type`: Literal["bearer"]

В коде при сохранении используется также **access_expires_at** (вычисляется как `int(time.time()) + expires_in`), в конфиге хранятся именно `access_token`, `refresh_token`, `access_expires_at`.

---

## 6. Команды и скрипты для пользователя

| Действие | Команда / скрипт |
|----------|-------------------|
| Авторизация (CLI) | `hh-applicant-tool authorize [email] [--password пароль]` или `authorize [email]` (код по почте/SMS) |
| Авторизация с видимым браузером | `hh-applicant-tool authorize --no-headless` |
| Авторизация через скрипт с паролем | `python authorize_with_password.py` (логин можно передать или ввести; пароль в скрипте или запросить) |
| Проверка авторизации | `python check_auth.py` или `hh-applicant-tool whoami` |
| Обновление токена | Выполняется автоматически при истечении access_token (в ApiClient); при необходимости вручную можно запустить `check_auth.py`, который при истёкшем токене сделает refresh и сохранит конфиг. |

---

## 7. Безопасность и рекомендации (из проекта)

- В `README_AI_BROWSER_INTEGRATION.md` указано: не хранить пароли в коде; токены — в локальном конфиге; ключи LLM — в переменных окружения или защищённом конфиге.
- В `authorize_with_password.py` пароль захардкожен (**PASSWORD = "..."**) — в репозитории такой файл лучше не коммитить или заменить на ввод/env.
- В `INTEGRATION_AI_BROWSER_SUMMARY.md` отмечено, что в `BROWSER_CAPTURE_GUIDE.md` могут быть реальные учётные данные — не хранить их в репозитории.

---

## 8. Связь с другими частями черновика

- **job-automation-resources:** авторизация через браузер; скрипты `autorize.bat`, `check_auth.py`; сбор данных по вакансиям/переговорам требует авторизации.
- **BPMN:** в процессе вакансии первый шаг — «Старт: авторизация или регистрация в сервисе».
- **apply_from_csv, отклики:** перед использованием рекомендуют проверить авторизацию (`hh-applicant-tool whoami`); скрипты берут токены из того же конфига.

---

## 9. Официальная документация API hh.ru: авторизация через API

Ниже — выжимка из **официальной документации** [api.hh.ru](https://api.hh.ru/openapi/redoc) и репозитория [hhru/api](https://github.com/hhru/api) по теме авторизации. Это то, на что опирается проект при работе с токенами.

### 9.1 Общая информация (OpenAPI Redoc)

- **Общая информация по API:** [https://api.hh.ru/openapi/redoc#section/Obshaya-informaciya](https://api.hh.ru/openapi/redoc#section/Obshaya-informaciya).
- **Раздел «Авторизация» в OpenAPI:** [https://api.hh.ru/openapi/redoc#section/Avtorizaciya](https://api.hh.ru/openapi/redoc#section/Avtorizaciya).
- **Авторизация соискателя** (наш случай): [https://api.hh.ru/openapi/redoc#tag/Avtorizaciya-soiskatelya](https://api.hh.ru/openapi/redoc#tag/Avtorizaciya-soiskatelya).
- **Спецификация OpenAPI:** [https://api.hh.ru/openapi/specification/public](https://api.hh.ru/openapi/specification/public) (в README указан также `openapi.yml`).

Подробное описание процесса авторизации пользователя (соискателя) в текущей версии документации вынесено в OpenAPI; в Markdown в репозитории даётся общая схема и ссылки.

### 9.2 Что говорит официальная документация (GitHub hhru/api)

**Файл [docs/authorization.md](https://github.com/hhru/api/blob/master/docs/authorization.md):**

- Для большинства запросов к API нужен **access-токен**.
- Авторизация по протоколу **OAuth 2.0**.
- Приложение не получает и не хранит логин/пароль пользователя — только запрашивает разрешение на доступ к данным.
- Два уровня авторизации:
  - [авторизация приложения](https://github.com/hhru/api/blob/master/docs/authorization_for_application.md) — токен приложения (для запросов от имени приложения);
  - [авторизация пользователя](https://github.com/hhru/api/blob/master/docs/authorization_for_user.md) — токен пользователя (соискатель/работодатель).
- **Важно:** для авторизации нужно использовать домен **hh.ru**; домен **m.hh.ru** для этого больше не доступен.

**Получение access-токена:**

- Токен приложения — см. [authorization_for_application.md](https://github.com/hhru/api/blob/master/docs/authorization_for_application.md) (в т.ч. раздел про получение токена приложения).
- Токен пользователя — см. [authorization_for_user.md](https://github.com/hhru/api/blob/master/docs/authorization_for_user.md); детали вынесены в [OpenAPI — «Авторизация пользователя»](https://api.hh.ru/openapi/redoc#section/Avtorizaciya/Avtorizaciya-polzovatelya).

**Использование access-токена:**

- Токен передаётся в заголовке в формате:  
  **`Authorization: Bearer ACCESS_TOKEN`**  
  Это совпадает с тем, как в проекте формируется заголовок в `ApiClient.default_headers()`.

**Проверка access-токена:**

- Рекомендуется использовать метод **`/me`**:
  - [для соискателя](https://api.hh.ru/openapi/redoc#tag/Informaciya-o-soiskatele/operation/get-current-user-info) — как в проекте (`api_client.get("/me")` в check_auth и т.п.).

**Ссылки из документации:**

- RFC 6749 (OAuth 2.0): [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749).
- Ошибки авторизации: раздел [errors.md#oauth](https://github.com/hhru/api/blob/master/docs/errors.md) в репозитории.

### 9.3 Регистрация приложения

- Методы, требующие авторизации пользователя или приложения, требуют **регистрации приложения** на [https://dev.hh.ru](https://dev.hh.ru) и настройки процесса авторизации ([authorization.md](https://github.com/hhru/api/blob/master/docs/authorization.md)).
- Личный кабинет разработчика: [https://dev.hh.ru/admin](https://dev.hh.ru/admin) — для просмотра/управления токеном приложения и настройками приложения.
- Если приложение только ищет вакансии **без авторизации**, регистрация не обязательна.

### 9.4 Соответствие проекта официальному API

| Требование API | Как в проекте |
|----------------|----------------|
| OAuth 2.0 | Используется; поток authorization_code + обмен кода на токен на `https://hh.ru/oauth/token`. |
| Домен hh.ru | Все OAuth-запросы идут на hh.ru (oauth client base_url = `https://hh.ru/oauth`). |
| Заголовок `Authorization: Bearer ACCESS_TOKEN` | В `ApiClient.default_headers()` добавляется `authorization: Bearer {access_token}`. |
| Проверка токена через `/me` | В `check_auth.py` и других местах вызывается `api_client.get("/me")`. |
| Refresh токена | Реализован вызов `POST .../token` с `grant_type=refresh_token` при истечении access_token. |

Итог: авторизация в проекте построена в соответствии с официальной документацией api.hh.ru по OAuth 2.0 и использованию Bearer-токена; детали эндпоинтов и параметров пользовательской авторизации при необходимости можно уточнять в [OpenAPI (раздел «Авторизация» / «Авторизация соискателя»)](https://api.hh.ru/openapi/redoc#section/Avtorizaciya).

---

## Краткое резюме

| Тема | Ответ |
|------|--------|
| **Авторизация** | OAuth 2.0 hh.ru через Playwright (браузер), имитация Android (client_id/secret Galaxy A55). |
| **Получение токена** | Перехват `hhandroid://oauth?code=...` → обмен кода на `access_token` и `refresh_token` через `https://hh.ru/oauth/token`. |
| **Сохранение токена** | В `config.json` в каталоге приложения (APPDATA/.config/...), ключ `token`; метод `Config.save(token=...)`. |
| **Обновление** | По `refresh_token` при истечении access_token (автоматически в ApiClient или через `check_auth.py`). |
| **Использование** | Заголовок `Authorization: Bearer <access_token>`; конфиг читается при старте CLI и в отдельных скриптах. |

Документ можно положить в основу структуры папок и модулей проекта RASHOTKLIK (например, разделы «auth», «config», «tokens» в коде или в документации).
=======
# Авторизация и токены в проекте автооткликов

**Назначение:** сводка по использованию авторизации, получению и сохранению токенов в черновике проекта автооткликов (Rezume / hh-applicant-tool).

---

## Краткий вывод

- **Где авторизация:** в подпроекте `hh-applicant-tool` через OAuth 2.0 hh.ru и браузер (Playwright).
- **Как получают токен:** перехват redirect `hhandroid://oauth?code=...` → обмен `code` на `access_token` и `refresh_token` через API hh.ru.
- **Где хранятся токены:** в файле `config.json` (путь зависит от ОС), через класс `Config` и метод `save(token=...)`.
- **Как используют:** все скрипты читают токен из `config.json`, подставляют в заголовок `Authorization: Bearer <access_token>`; при истечении — обновляют через `refresh_token` и снова сохраняют в конфиг.

---

## 1. Где происходит авторизация

| Что | Где |
|-----|-----|
| **Основная точка входа** | `hh-applicant-tool` (CLI и операции) |
| **Код авторизации (OAuth в браузере)** | `hh-applicant-tool/hh_applicant_tool/operations/authorize.py` |
| **Альтернативный скрипт с паролем** | `hh-applicant-tool/authorize_with_password.py` |
| **Проверка авторизации** | `hh-applicant-tool/check_auth.py` |
| **Документация по интеграции** | `README_AI_BROWSER_INTEGRATION.md`, `INTEGRATION_AI_BROWSER_SUMMARY.md` |
| **Упоминания в других частях проекта** | `job-automation-resources/CODE_MAP.md`, `job-automation-resources/ДАННЫЕ_СБОРА_АНАЛИЗ.md`, `BPMN/vacancy_application_process_with_api.md` |

---

## 2. Как получают токен авторизации

### 2.1 OAuth-поток (authorize.py)

1. Запускается **Playwright** (Chromium), контекст устройства — **Galaxy A55** (имитация Android).
2. Переход на `api_client.oauth_client.authorize_url` (страница OAuth hh.ru).
3. Пользователь вводит логин (email/телефон) и либо пароль, либо одноразовый код.
4. После входа hh.ru перенаправляет на схему **`hhandroid://oauth?code=...`**.
5. Обработчик `page.on("request", handle_request)` **перехватывает** этот redirect и извлекает `code` из URL.
6. Код обменивается на токены через **OAuthClient**:
   - `api_client.oauth_client.authenticate(auth_code)` → запрос к `https://hh.ru/oauth/token` с `grant_type=authorization_code` и `code=...`.
7. Ответ содержит `access_token`, `refresh_token`, `expires_in`. В коде добавляется `access_expires_at = time.time() + expires_in`.
8. Токен передаётся в **ApiClient**: `api_client.handle_access_token(token)`.

**Ключевые места в коде:**

- Перехват кода: `hh_applicant_tool/operations/authorize.py` (строки ~131–139, 164–176).
- Обмен кода на токен: `hh_applicant_tool/api/client.py` — `OAuthClient.authenticate(code)` и `request_access_token("/token", params)`.
- Имитация Android: используются константы `ANDROID_CLIENT_ID` и `ANDROID_CLIENT_SECRET` из `hh_applicant_tool/constants.py`.

### 2.2 Обновление токена (refresh)

- При истечении `access_token` (проверка `api_client.is_access_expired`) вызывается `api_client.refresh_access_token()`.
- Запрос к `https://hh.ru/oauth/token` с `grant_type=refresh_token` и `refresh_token=...`.
- Новый `access_token` и при необходимости новый `refresh_token` записываются в ApiClient через `handle_access_token(token)`.
- Обновлённый токен сохраняется в конфиг (см. ниже).

**Код:** `hh_applicant_tool/api/client.py` — метод `refresh_access_token()` у `OAuthClient` и у `ApiClient`; автоматический refresh при 403 в `ApiClient.request()`.

---

## 3. Сохранение токена

### 3.1 Куда сохраняется

- **Файл:** `config.json`.
- **Путь к файлу** (функция `get_config_path()` в `hh_applicant_tool/utils.py`):
  - **Windows:** `%APPDATA%\hh-applicant-tool\config.json` (например, `C:\Users\<user>\AppData\Roaming\hh-applicant-tool\config.json`).
  - **macOS:** `~/Library/Application Support/hh-applicant-tool/config.json`.
  - **Linux/прочее:** `$XDG_CONFIG_HOME/hh-applicant-tool/config.json` или `~/.config/hh-applicant-tool/config.json`.

Полный путь в коде часто собирается как:  
`get_config_path() / "hh-applicant-tool" / "config.json"`.

### 3.2 Как сохраняется

- Класс **Config** (`hh_applicant_tool/utils.py`): наследует `dict`, метод `save(*args, **kwargs)` делает `self.update(*args, **kwargs)` и записывает JSON в `_config_path`.
- Сохранение токена: `config.save(token=token)`, где `token` — словарь вида:
  - `access_token`: строка
  - `refresh_token`: строка
  - `access_expires_at`: int (Unix timestamp)

В конфиге токен лежит под ключом **`token`** (т.е. в `config["token"]`).

### 3.3 Где вызывается сохранение

| Место | Действие |
|-------|----------|
| `hh_applicant_tool/main.py` | После любой операции (`args.run`): если `api_client.get_access_token()` отличается от `args.config["token"]`, вызывается `args.config.save(token=token)`. Таким образом, после авторизации или refresh токен автоматически попадает в конфиг. |
| `hh_applicant_tool/operations/authorize.py` | Сама операция только вызывает `api_client.handle_access_token(token)`; запись в конфиг выполняет общий код в `main.py` после `args.run`. |
| `authorize_with_password.py` | После успешной авторизации: `config.save(token=api_client.get_access_token())`. |
| `check_auth.py` | После успешного обновления токена по refresh: `config.save(token=api_client.get_access_token())`. |

---

## 4. Использование токена в запросах

- **ApiClient** при наличии `access_token` добавляет в заголовки:  
  `authorization: Bearer <access_token>`  
  (в коде: `headers | {"authorization": f"Bearer {self.access_token}"}`).
- Токены загружаются из конфига при создании ApiClient в `main.py`:  
  `config.get("token", {})` → `access_token`, `refresh_token`, `access_expires_at` передаются в конструктор ApiClient.
- Отдельные скрипты (например, `check_negotiations_structure.py`, `analyze_negotiations_list.py`, `test_vacancy_from_negotiation_click.py`, `create_mobile_client.py` и др.) сами читают `config.json`, достают `config.get("token", {}).get("access_token")` и либо создают ApiClient с этими полями, либо подставляют заголовок `Authorization: Bearer {access_token}` в свои запросы.

---

## 5. Тип токена (структура)

В `hh_applicant_tool/types.py` описан **AccessToken** (TypedDict):

- `access_token`: str  
- `refresh_token`: str  
- `expires_in`: int  
- `token_type`: Literal["bearer"]

В коде при сохранении используется также **access_expires_at** (вычисляется как `int(time.time()) + expires_in`), в конфиге хранятся именно `access_token`, `refresh_token`, `access_expires_at`.

---

## 6. Команды и скрипты для пользователя

| Действие | Команда / скрипт |
|----------|-------------------|
| Авторизация (CLI) | `hh-applicant-tool authorize [email] [--password пароль]` или `authorize [email]` (код по почте/SMS) |
| Авторизация с видимым браузером | `hh-applicant-tool authorize --no-headless` |
| Авторизация через скрипт с паролем | `python authorize_with_password.py` (логин можно передать или ввести; пароль в скрипте или запросить) |
| Проверка авторизации | `python check_auth.py` или `hh-applicant-tool whoami` |
| Обновление токена | Выполняется автоматически при истечении access_token (в ApiClient); при необходимости вручную можно запустить `check_auth.py`, который при истёкшем токене сделает refresh и сохранит конфиг. |

---

## 7. Безопасность и рекомендации (из проекта)

- В `README_AI_BROWSER_INTEGRATION.md` указано: не хранить пароли в коде; токены — в локальном конфиге; ключи LLM — в переменных окружения или защищённом конфиге.
- В `authorize_with_password.py` пароль захардкожен (**PASSWORD = "..."**) — в репозитории такой файл лучше не коммитить или заменить на ввод/env.
- В `INTEGRATION_AI_BROWSER_SUMMARY.md` отмечено, что в `BROWSER_CAPTURE_GUIDE.md` могут быть реальные учётные данные — не хранить их в репозитории.

---

## 8. Связь с другими частями черновика

- **job-automation-resources:** авторизация через браузер; скрипты `autorize.bat`, `check_auth.py`; сбор данных по вакансиям/переговорам требует авторизации.
- **BPMN:** в процессе вакансии первый шаг — «Старт: авторизация или регистрация в сервисе».
- **apply_from_csv, отклики:** перед использованием рекомендуют проверить авторизацию (`hh-applicant-tool whoami`); скрипты берут токены из того же конфига.

---

## 9. Официальная документация API hh.ru: авторизация через API

Ниже — выжимка из **официальной документации** [api.hh.ru](https://api.hh.ru/openapi/redoc) и репозитория [hhru/api](https://github.com/hhru/api) по теме авторизации. Это то, на что опирается проект при работе с токенами.

### 9.1 Общая информация (OpenAPI Redoc)

- **Общая информация по API:** [https://api.hh.ru/openapi/redoc#section/Obshaya-informaciya](https://api.hh.ru/openapi/redoc#section/Obshaya-informaciya).
- **Раздел «Авторизация» в OpenAPI:** [https://api.hh.ru/openapi/redoc#section/Avtorizaciya](https://api.hh.ru/openapi/redoc#section/Avtorizaciya).
- **Авторизация соискателя** (наш случай): [https://api.hh.ru/openapi/redoc#tag/Avtorizaciya-soiskatelya](https://api.hh.ru/openapi/redoc#tag/Avtorizaciya-soiskatelya).
- **Спецификация OpenAPI:** [https://api.hh.ru/openapi/specification/public](https://api.hh.ru/openapi/specification/public) (в README указан также `openapi.yml`).

Подробное описание процесса авторизации пользователя (соискателя) в текущей версии документации вынесено в OpenAPI; в Markdown в репозитории даётся общая схема и ссылки.

### 9.2 Что говорит официальная документация (GitHub hhru/api)

**Файл [docs/authorization.md](https://github.com/hhru/api/blob/master/docs/authorization.md):**

- Для большинства запросов к API нужен **access-токен**.
- Авторизация по протоколу **OAuth 2.0**.
- Приложение не получает и не хранит логин/пароль пользователя — только запрашивает разрешение на доступ к данным.
- Два уровня авторизации:
  - [авторизация приложения](https://github.com/hhru/api/blob/master/docs/authorization_for_application.md) — токен приложения (для запросов от имени приложения);
  - [авторизация пользователя](https://github.com/hhru/api/blob/master/docs/authorization_for_user.md) — токен пользователя (соискатель/работодатель).
- **Важно:** для авторизации нужно использовать домен **hh.ru**; домен **m.hh.ru** для этого больше не доступен.

**Получение access-токена:**

- Токен приложения — см. [authorization_for_application.md](https://github.com/hhru/api/blob/master/docs/authorization_for_application.md) (в т.ч. раздел про получение токена приложения).
- Токен пользователя — см. [authorization_for_user.md](https://github.com/hhru/api/blob/master/docs/authorization_for_user.md); детали вынесены в [OpenAPI — «Авторизация пользователя»](https://api.hh.ru/openapi/redoc#section/Avtorizaciya/Avtorizaciya-polzovatelya).

**Использование access-токена:**

- Токен передаётся в заголовке в формате:  
  **`Authorization: Bearer ACCESS_TOKEN`**  
  Это совпадает с тем, как в проекте формируется заголовок в `ApiClient.default_headers()`.

**Проверка access-токена:**

- Рекомендуется использовать метод **`/me`**:
  - [для соискателя](https://api.hh.ru/openapi/redoc#tag/Informaciya-o-soiskatele/operation/get-current-user-info) — как в проекте (`api_client.get("/me")` в check_auth и т.п.).

**Ссылки из документации:**

- RFC 6749 (OAuth 2.0): [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749).
- Ошибки авторизации: раздел [errors.md#oauth](https://github.com/hhru/api/blob/master/docs/errors.md) в репозитории.

### 9.3 Регистрация приложения

- Методы, требующие авторизации пользователя или приложения, требуют **регистрации приложения** на [https://dev.hh.ru](https://dev.hh.ru) и настройки процесса авторизации ([authorization.md](https://github.com/hhru/api/blob/master/docs/authorization.md)).
- Личный кабинет разработчика: [https://dev.hh.ru/admin](https://dev.hh.ru/admin) — для просмотра/управления токеном приложения и настройками приложения.
- Если приложение только ищет вакансии **без авторизации**, регистрация не обязательна.

### 9.4 Соответствие проекта официальному API

| Требование API | Как в проекте |
|----------------|----------------|
| OAuth 2.0 | Используется; поток authorization_code + обмен кода на токен на `https://hh.ru/oauth/token`. |
| Домен hh.ru | Все OAuth-запросы идут на hh.ru (oauth client base_url = `https://hh.ru/oauth`). |
| Заголовок `Authorization: Bearer ACCESS_TOKEN` | В `ApiClient.default_headers()` добавляется `authorization: Bearer {access_token}`. |
| Проверка токена через `/me` | В `check_auth.py` и других местах вызывается `api_client.get("/me")`. |
| Refresh токена | Реализован вызов `POST .../token` с `grant_type=refresh_token` при истечении access_token. |

Итог: авторизация в проекте построена в соответствии с официальной документацией api.hh.ru по OAuth 2.0 и использованию Bearer-токена; детали эндпоинтов и параметров пользовательской авторизации при необходимости можно уточнять в [OpenAPI (раздел «Авторизация» / «Авторизация соискателя»)](https://api.hh.ru/openapi/redoc#section/Avtorizaciya).

---

## Краткое резюме

| Тема | Ответ |
|------|--------|
| **Авторизация** | OAuth 2.0 hh.ru через Playwright (браузер), имитация Android (client_id/secret Galaxy A55). |
| **Получение токена** | Перехват `hhandroid://oauth?code=...` → обмен кода на `access_token` и `refresh_token` через `https://hh.ru/oauth/token`. |
| **Сохранение токена** | В `config.json` в каталоге приложения (APPDATA/.config/...), ключ `token`; метод `Config.save(token=...)`. |
| **Обновление** | По `refresh_token` при истечении access_token (автоматически в ApiClient или через `check_auth.py`). |
| **Использование** | Заголовок `Authorization: Bearer <access_token>`; конфиг читается при старте CLI и в отдельных скриптах. |

Документ можно положить в основу структуры папок и модулей проекта RASHOTKLIK (например, разделы «auth», «config», «tokens» в коде или в документации).
